import networkx as nx
import collections

# 1)
"""
Оценить асимптотическую сложность приведенного ниже алгоритма:
"""
# a = len(arr) - 1        # O(1) - определение длины массива
# out = list()            # O(1) - созданиие пустого списка (по сути создание одной ссылки на начало)
# while a > 0:            # O(n * (log по основанию 1.7 от n))
#     out.append(arr[a])    # O(n) - вставка в массив - в худшем случае у него с конца не будет места
#                                       и его ВЕСЬ прийдется перезаписывать в другой блок памяти
#     a = a // 1.7          # O(1)
# out.merge_sort()        # O(nlog(n))
# Итоговая сложность = max (т.к. действия последовательны - цикл рассматриваю цельным объектом) - O(nlogn)

# 2)
"""
Дано N человек, считалка из K слогов.
Считалка начинает считать с первого человека.
Когда считалка досчитывает до k-го слога, человек, на котором она остановилась, вылетает.
Игра происходит до тех пор, пока не останется последний человек.
Для данных N и К дать номер последнего оставшегося человека.
"""


def counting(n: int, k: int):
    q = [i for i in range(n)]
    i = k
    while n > 1:
        if n > i:
            q.pop(i)
            n -= 1
            while n > i:
                i += k - 1
                q.pop(i)
                n -= 1
            i -= n
        else:
            i -= n
    return q.pop()


# 3)


def connect_comp(g: nx.Graph):
    """
    Функция происзводит посчет ко   мпонент связности.
    :param g: граф
    :return: коичество компонент связности
    """
    nodes = set(g.nodes())
    n = 0

    while nodes:
        start = nodes.pop()
        queue = [start, ]
        viewed = [start, ]
        res = set()
        while len(queue):
            n = queue.pop()
            res.add(n)
            for neighbor in g.neighbors(n):
                if neighbor not in viewed:
                    queue.append(neighbor)
                    viewed.append(neighbor)

        nodes -= res
        n += 1

    return n


# 5)
"""
5.	Задача консенсуса DNA ридов
При чтении DNA последовательностей могут возникать единичные ошибки, выражающиеся в неверной букве в строке.
Для решения данной проблемы требуемое место читается несколько раз, после чего строится консенсус-строка,
в которой на каждом месте будет стоять тот символ, что чаще всего встречался в этом месте суммарно во всех чтениях.
Т.е. для строк: 
ATTA
ACTA
AGCA
ACAA
консенсус-строка будет ACTA
(в первой ячейке чаще всего встречалась A, во второй – C, в третьей – Т, в четвертой – снова А).
Для входного списка из N строк одинаковой длины построить консенсус-строку.
"""


def DNA_read(roster: list) -> str:
    """
    Функция реализует формирование строки из наиболее часто встречающихся букв на определенном месте в каждом элементе.
    :param roster: Входной список строк одинаковой длины для анализа
    :return: Строка правильного содержания
    """
    width = len(roster[0])
    d = {i: {} for i in range(width)}
    for elem in roster:
        for i in range(width):
            if elem[i] in d[i]:
                d[i][elem[i]] += 1
            else:
                d[i][elem[i]] = 0
    res = ''
    for small_dict in d:
        res += small_dict.items().sort(key=lambda x: x[1])[0][0]
    return res


# 6)
"""
Аренда ракет

Вы – компания, дающая в аренду ракеты. 
Каждый день к вам приходит список заявок на использование ракет в виде: 
(час_начала, час_конца), (час_начала, час_конца), ...
Если аренда ракеты заканчивается в час X, то в этот же час ее уже можно взять в аренду снова 
(т.е. час_начала может начинаться с Х).
Дано: список заявок на использование ракет
Задача: вывести ответ, хватит ли вам одной ракеты, чтобы удовлетворить все заявки на этот день
"""


def sum_time(queue: list) -> bool:
    """
    Функция проверяет возможность удовлетворения ВСЕХ поданных заявок - сравнивает время окончания каждой
    с временем начала следующей.
    :param queue: список заявок
    :return: bool
    """
    for i in range(len(queue) - 1):
        if queue[i][1] > queue[i + 1][0]:
            return False
    return True


# Интересней была бы задача на определение максимального кол-ва заявок, которые можно удовлетворить

# 7)
"""
Дано: массив из 10**6 целых чисел, каждое из которых лежит на отрезке [13, 25].
Задача: отсортировать массив наиболее эффективным способом
"""
# Если выбирать между теми на которых нам делали акцент (quick/merge), то:
# Целесообразно использовать сортировку слиянием, т.к. много однообразных значений.
# А сортировка слиянием обладает свойством устойчивости.
#
# Но для данного случая я бы выбрал сортировку подсчётом (counting sort)


def count_sort(block: list) -> list:
    """
    Функция реализует сортировку  подсчетом
    :param block: Исходный список
    :return: Отсортированный список
    """
    count_buffer = collections.defaultdict(int)
    res = []
    for elem in block:
        count_buffer[elem] += 1
    for num in range(13, 26):
        res.extend([num, ] * count_buffer[num])
    return res
